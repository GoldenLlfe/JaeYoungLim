# -*- coding: utf-8 -*-
"""21_12_10_day10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1--Kz7ToF5CZghX9J6GrX8adJ1uw1ZrVm

## Transformer

기존의 seq2seq 모델의 한계
- 입력 시퀀스를 하나의 벡터표현으로 압축 (context vector) 디코더는 이를 통해 출력 시퀀스를 만들어냄
- 정보가 일부 손실된다는 단점

- $d_{model}$ = 512
- num_layers = 6
- num_heads = 8
- $d_{ff}$ = 2048

### 포지셔널 인코딩

$$PE_(pose, 2i) = sin(pos/1000^{2i/d_{model}})$$
$$PE_(pose, 2i+1) = cos(pos/1000^{2i/d_{model}})$$
"""

import tensorflow as tf
import matplotlib.pyplot as plt
import numpy as np

class PositionalEncoding(tf.keras.layers.Layer):
  def __init__(self, position, d_model):
    super(PositionalEncoding, self).__init__()
    self.pos_encoding = self.positional_encoding(position, d_model)

  def get_angles(self, position, i, d_model):
    angles = 1 / tf.pow(10000, (2 * (i // 2)) / tf.cast(d_model, tf.float32))
    return position * angles

  def positional_encoding(self, position, d_model):
    angle_rads = self.get_angles(
        position=tf.range(position, dtype=tf.float32)[:, tf.newaxis],
        i=tf.range(d_model, dtype=tf.float32)[tf.newaxis, :],
        d_model=d_model)

    # 배열의 짝수 인덱스(2i)에는 사인 함수 적용
    sines = tf.math.sin(angle_rads[:, 0::2])

    # 배열의 홀수 인덱스(2i+1)에는 코사인 함수 적용
    cosines = tf.math.cos(angle_rads[:, 1::2])

    angle_rads = np.zeros(angle_rads.shape)
    angle_rads[:, 0::2] = sines
    angle_rads[:, 1::2] = cosines
    pos_encoding = tf.constant(angle_rads)
    pos_encoding = pos_encoding[tf.newaxis, ...]

    print(pos_encoding.shape)
    return tf.cast(pos_encoding, tf.float32)

  def call(self, inputs):
    return inputs + self.pos_encoding[:, :tf.shape(inputs)[1], :]

# 50x 128크기를 가지는 포지셔널 인코딩 행렬을 시각화하기
# 입력문자의 단어가 50 각 단어가 128차원의 임베딩 벡터를 가질 때 사용하는 행렬

sample_pos_encoding = PositionalEncoding(50, 128)

plt.pcolormesh(sample_pos_encoding.pos_encoding.numpy()[0], cmap = "RdBu")
plt.xlabel('Depth')
plt.xlim((0, 128))
plt.ylabel('Position')
plt.colorbar()
plt.show()

def scaled_dot_product_attention(query, key, value, mask):
    # query 크기 : (batch_size, num_heads, query의 문장 길이, d_model/num_heads)
    # key 크기 : (batch_size, num_heads, key의 문장 길이, d_model/num_heads)
    # value 크기 : (batch_size, num_heads, value의 문장 길이, d_model/num_heads)
    # padding mask : (batch_size, 1, 1, key의 문장 길이)

    # Q와 K의 곱
    matmul_qk = tf.matmul(query, key, transpose_b=True)

    # 스케일링 : dk의 루트값으로 나눈다.
    depth = tf.cast(tf.shape(key)[-1], tf.float32)
    logits = matmul_qk /tf.math.sqrt(depth)

    # 마스킹 어텐션 스코어 행렬의 마스킹 할 위치에 매우 작은 음수값을 넣는다.
    # 매우 작은 값이므로 소프트맥스 함수를 지나면 행렬의 해당 위치의 값은 0이 된다.
    if mask is not None:
        logits += (mask * -1e9)

    # 소프트맥스 함수는 마지막 차원인 key의 문장 길이 방향으로 수행된다.
    # attention weight : (batch_size, num_heads, query의 문장 길이, key의 문장 길이)
    attention_weight = tf.nn.softmax(logits, axis=-1)

    # output : (batch_size, num_heads, query의 문장 길이 , d_model/num_heads)
    output = tf.matmul(attention_weight, value)

    return output, attention_weight

# scaled_dot_product_attention함수가 정상적으로 작동하는지 테스트 !
np.set_printoptions(suppress=True)
temp_k = tf.constant([[10, 0, 0],
                      [0, 10, 0],
                     [0, 0, 10],
                     [0, 0, 10]], dtype=tf.float32) # (4, 3)
temp_v = tf.constant([[  1, 0],
                     [  10, 0],
                     [ 100, 5],
                     [1000, 6]], dtype=tf.float32) # (4, 2)
temp_q = tf.constant([[0, 10, 0]], dtype = tf.float32) # (1, 3)

temp_out, temp_attn = scaled_dot_product_attention(temp_q, temp_k, temp_v, None)
print(temp_attn) # 어텐션 분포
print(temp_out) # 어텐션 값

# scaled_dot_product_attention함수가 정상적으로 작동하는지 테스트 !
np.set_printoptions(suppress=True)
temp_k = tf.constant([[10, 0, 0],
                      [0, 10, 0],
                     [0, 0, 10],
                     [0, 0, 10]], dtype=tf.float32) # (4, 3)
temp_v = tf.constant([[  1, 0],
                     [  10, 0],
                     [ 100, 5],
                     [1000, 6]], dtype=tf.float32) # (4, 2)
temp_q = tf.constant([[0, 0, 10]], dtype = tf.float32) # (1, 3)

temp_out, temp_attn = scaled_dot_product_attention(temp_q, temp_k, temp_v, None)
print(temp_attn) # 어텐션 분포
print(temp_out) # 어텐션 값

temp_k = tf.constant([[10, 0, 0],
                      [0, 10, 0],
                     [0, 0, 10],
                     [0, 0, 10]], dtype=tf.float32) # (4, 3)
temp_v = tf.constant([[  1, 0],
                     [  10, 0],
                     [ 100, 5],
                     [1000, 6]], dtype=tf.float32) # (4, 2)
temp_q = tf.constant([[0, 0, 10],
                      [0, 10, 0],
                      [10, 10, 0]], dtype = tf.float32) # (1, 3)

temp_out, temp_attn = scaled_dot_product_attention(temp_q, temp_k, temp_v, None)
print(temp_attn) # 어텐션 분포
print(temp_out) # 어텐션 값

"""### 멀티-헤드 어텐션

![](https://wikidocs.net/images/page/31379/transformer17.PNG)

병렬 어텐션의 효과?


머리가 여러개이기 때문에, 여러 시점에서 상대방을 볼 수있다.

1. $W_Q, W_k, W_v$에 해당하는 $d_{model}$크기의 밀집층(Dense layer)을 지남
2. 지정된 헤드 수 (num_heads)만큼 나눈다.
3. 스케일드 닷 프로덕트 어텐션
4. 나눠졌던 헤드들을 연결한다.
5. $W_0$에 해당하는 밀집층을 지나게 된다.
"""

class MultiHeadAttention(tf.keras.layers.Layer):

  def __init__(self, d_model, num_heads, name="multi_head_attention"):
    super(MultiHeadAttention, self).__init__(name=name)
    self.num_heads = num_heads
    self.d_model = d_model

    assert d_model % self.num_heads == 0

    # d_model을 num_heads로 나눈 값.
    # 논문 기준 : 64
    self.depth = d_model // self.num_heads

    # WQ, WK, WV에 해당하는 밀집층 정의
    self.query_dense = tf.keras.layers.Dense(units=d_model)
    self.key_dense = tf.keras.layers.Dense(units=d_model)
    self.value_dense = tf.keras.layers.Dense(units=d_model)

    # WO에 해당하는 밀집층 정의
    self.dense = tf.keras.layers.Dense(units=d_model)

  # num_heads 개수만큼 q, k, v를 split하는 함수
  def split_heads(self, inputs, batch_size):
    inputs = tf.reshape(
        inputs, shape=(batch_size, -1, self.num_heads, self.depth))
    return tf.transpose(inputs, perm=[0, 2, 1, 3])

  def call(self, inputs):
    query, key, value, mask = inputs['query'], inputs['key'], inputs[
        'value'], inputs['mask']
    batch_size = tf.shape(query)[0]

    # 1. WQ, WK, WV에 해당하는 밀집층 지나기
    # q : (batch_size, query의 문장 길이, d_model)
    # k : (batch_size, key의 문장 길이, d_model)
    # v : (batch_size, value의 문장 길이, d_model)
    # 참고) 인코더(k, v)-디코더(q) 어텐션에서는 query 길이와 key, value의 길이는 다를 수 있다.
    query = self.query_dense(query)
    key = self.key_dense(key)
    value = self.value_dense(value)

    # 2. 헤드 나누기
    # q : (batch_size, num_heads, query의 문장 길이, d_model/num_heads)
    # k : (batch_size, num_heads, key의 문장 길이, d_model/num_heads)
    # v : (batch_size, num_heads, value의 문장 길이, d_model/num_heads)
    query = self.split_heads(query, batch_size)
    key = self.split_heads(key, batch_size)
    value = self.split_heads(value, batch_size)

    # 3. 스케일드 닷 프로덕트 어텐션. 앞서 구현한 함수 사용.
    # (batch_size, num_heads, query의 문장 길이, d_model/num_heads)
    scaled_attention, _ = scaled_dot_product_attention(query, key, value, mask)
    # (batch_size, query의 문장 길이, num_heads, d_model/num_heads)
    scaled_attention = tf.transpose(scaled_attention, perm=[0, 2, 1, 3])

    # 4. 헤드 연결(concatenate)하기
    # (batch_size, query의 문장 길이, d_model)
    concat_attention = tf.reshape(scaled_attention,
                                  (batch_size, -1, self.d_model))

    # 5. WO에 해당하는 밀집층 지나기
    # (batch_size, query의 문장 길이, d_model)
    outputs = self.dense(concat_attention)

    return outputs

"""### 패딩 마스크

![](https://wikidocs.net/images/page/31379/pad_masking2.PNG)
"""

def create_padding_mask(x):
  mask = tf.cast(tf.math.equal(x, 0), tf.float32)
  # (batch_size, 1, 1, key의 문장 길이)
  return mask[:, tf.newaxis, tf.newaxis, :]

print(create_padding_mask(tf.constant([[1, 21, 777, 0, 0]])))

"""### 포지션 와이드 피드 포워드 신경망

```
outputs = tf.keras.layers.Dense(units=dff, activation='relu')(attention)
outpus = tf.kears.layers.Dense(units=d_model)(outpus)
```

### 인코더 구현하기
"""

def encoder_layer(dff, d_model, num_heads, dropout, name="encoder_layer"):
  inputs = tf.keras.layers.Input(shape=(None, d_model), name="inputs")

  # 인코더는 패딩 마스크 사용
  padding_mask = tf.keras.layers.Input(shape=(1, 1, None), name="padding_mask")

  # 멀티-헤드 어텐션 (첫번째 서브층 / 셀프 어텐션)
  attention = MultiHeadAttention(
      d_model, num_heads, name="attention")({
          'query': inputs, 'key': inputs, 'value': inputs, # Q = K = V
          'mask': padding_mask # 패딩 마스크 사용
      })

  # 드롭아웃 + 잔차 연결과 층 정규화
  attention = tf.keras.layers.Dropout(rate=dropout)(attention)
  attention = tf.keras.layers.LayerNormalization(
      epsilon=1e-6)(inputs + attention)

  # 포지션 와이즈 피드 포워드 신경망 (두번째 서브층)
  outputs = tf.keras.layers.Dense(units=dff, activation='relu')(attention)
  outputs = tf.keras.layers.Dense(units=d_model)(outputs)

  # 드롭아웃 + 잔차 연결과 층 정규화
  outputs = tf.keras.layers.Dropout(rate=dropout)(outputs)
  outputs = tf.keras.layers.LayerNormalization(
      epsilon=1e-6)(attention + outputs)

  return tf.keras.Model(
      inputs=[inputs, padding_mask], outputs=outputs, name=name)

"""### 인코더 쌓기"""

def encoder(vocab_size, num_layers, dff,
            d_model, num_heads, dropout,
            name="encoder"):
  inputs = tf.keras.layers.Input(shape=(None,), name="inputs")

  # 인코더는 패딩 마스크 사용
  padding_mask = tf.keras.layers.Input(shape=(1, 1, None), name="padding_mask")

  # 포지셔널 인코딩 + 드롭아웃
  embeddings = tf.keras.layers.Embedding(vocab_size, d_model)(inputs)
  embeddings *= tf.math.sqrt(tf.cast(d_model, tf.float32))
  embeddings = PositionalEncoding(vocab_size, d_model)(embeddings)
  outputs = tf.keras.layers.Dropout(rate=dropout)(embeddings)

  # 인코더를 num_layers개 쌓기
  for i in range(num_layers):
    outputs = encoder_layer(dff=dff, d_model=d_model, num_heads=num_heads,
        dropout=dropout, name="encoder_layer_{}".format(i),
    )([outputs, padding_mask])

  return tf.keras.Model(
      inputs=[inputs, padding_mask], outputs=outputs, name=name)

"""### 디코더의 첫번째 서브층 : self 어텐션과 룩-헤드 마스크

- 인코더에 있는 self어텐션 : 패딩마스크전달
- 디코더와 첫번째 서브층인 masked self attention : 룩-어헤드 마스크전달
- 디코더의 두번째 서브층인 인코더-디코더 어텐션 : 패딩마스크전달
"""

# 디코더의 첫번째 서브층에서 미래 토큰을 mask하는 함수
def create_look_ahead_mask(x):
    seq_len = tf.shape(x)[1]
    look_ahead_mask = 1-tf.linalg.band_part(tf.ones((seq_len, seq_len)), -1, 0)
    padding_mask = create_padding_mask(x) # 패딩 마스크 포함
    return tf.maximum(look_ahead_mask, padding_mask)

print(create_look_ahead_mask(tf.constant([[1, 2, 0, 4, 5]])))

"""### 디코더의 두번째 서브층 : 인코더-디코더 어텐션
- 인코더의 첫번째 서브층 : Query = Key = Value
- 디코더의 첫번쨰 서브층 : Query = Key = Value
- 디코더의 두번째 서브층 : Query(디코더행렬) // key= value (인코더행렬)
"""

def decoder_layer(dff, d_model, num_heads, dropout, name="decoder_layer"):
  inputs = tf.keras.layers.Input(shape=(None, d_model), name="inputs")
  enc_outputs = tf.keras.layers.Input(shape=(None, d_model), name="encoder_outputs")

  # 디코더는 룩어헤드 마스크(첫번째 서브층)와 패딩 마스크(두번째 서브층) 둘 다 사용.
  look_ahead_mask = tf.keras.layers.Input(
      shape=(1, None, None), name="look_ahead_mask")
  padding_mask = tf.keras.Input(shape=(1, 1, None), name='padding_mask')

  # 멀티-헤드 어텐션 (첫번째 서브층 / 마스크드 셀프 어텐션)
  attention1 = MultiHeadAttention(
      d_model, num_heads, name="attention_1")(inputs={
          'query': inputs, 'key': inputs, 'value': inputs, # Q = K = V
          'mask': look_ahead_mask # 룩어헤드 마스크
      })

  # 잔차 연결과 층 정규화
  attention1 = tf.keras.layers.LayerNormalization(
      epsilon=1e-6)(attention1 + inputs)

  # 멀티-헤드 어텐션 (두번째 서브층 / 디코더-인코더 어텐션)
  attention2 = MultiHeadAttention(
      d_model, num_heads, name="attention_2")(inputs={
          'query': attention1, 'key': enc_outputs, 'value': enc_outputs, # Q != K = V
          'mask': padding_mask # 패딩 마스크
      })

  # 드롭아웃 + 잔차 연결과 층 정규화
  attention2 = tf.keras.layers.Dropout(rate=dropout)(attention2)
  attention2 = tf.keras.layers.LayerNormalization(
      epsilon=1e-6)(attention2 + attention1)

  # 포지션 와이즈 피드 포워드 신경망 (세번째 서브층)
  outputs = tf.keras.layers.Dense(units=dff, activation='relu')(attention2)
  outputs = tf.keras.layers.Dense(units=d_model)(outputs)

  # 드롭아웃 + 잔차 연결과 층 정규화
  outputs = tf.keras.layers.Dropout(rate=dropout)(outputs)
  outputs = tf.keras.layers.LayerNormalization(
      epsilon=1e-6)(outputs + attention2)

  return tf.keras.Model(
      inputs=[inputs, enc_outputs, look_ahead_mask, padding_mask],
      outputs=outputs,
      name=name)

def decoder(vocab_size, num_layers, dff,
            d_model, num_heads, dropout,
            name='decoder'):
  inputs = tf.keras.layers.Input(shape=(None,), name='inputs')
  enc_outputs = tf.keras.layers.Input(shape=(None, d_model), name='encoder_outputs')

  # 디코더는 룩어헤드 마스크(첫번째 서브층)와 패딩 마스크(두번째 서브층) 둘 다 사용.
  look_ahead_mask = tf.keras.layers.Input(
      shape=(1, None, None), name='look_ahead_mask')
  padding_mask = tf.keras.Input(shape=(1, 1, None), name='padding_mask')

  # 포지셔널 인코딩 + 드롭아웃
  embeddings = tf.keras.layers.Embedding(vocab_size, d_model)(inputs)
  embeddings *= tf.math.sqrt(tf.cast(d_model, tf.float32))
  embeddings = PositionalEncoding(vocab_size, d_model)(embeddings)
  outputs = tf.keras.layers.Dropout(rate=dropout)(embeddings)

  # 디코더를 num_layers개 쌓기
  for i in range(num_layers):
    outputs = decoder_layer(dff=dff, d_model=d_model, num_heads=num_heads,
        dropout=dropout, name='decoder_layer_{}'.format(i),
    )(inputs=[outputs, enc_outputs, look_ahead_mask, padding_mask])

  return tf.keras.Model(
      inputs=[inputs, enc_outputs, look_ahead_mask, padding_mask],
      outputs=outputs,
      name=name)

"""### 트랜스포머 구현하기 """

def transformer(vocab_size, num_layers, dff,
                d_model, num_heads, dropout,
                name="transformer"):

  # 인코더의 입력
  inputs = tf.keras.layers.Input(shape=(None,), name="inputs")

  # 디코더의 입력
  dec_inputs = tf.keras.layers.Input(shape=(None,), name="dec_inputs")

  # 인코더의 패딩 마스크
  enc_padding_mask = tf.keras.layers.Lambda(
      create_padding_mask, output_shape=(1, 1, None),
      name='enc_padding_mask')(inputs)

  # 디코더의 룩어헤드 마스크(첫번째 서브층)
  look_ahead_mask = tf.keras.layers.Lambda(
      create_look_ahead_mask, output_shape=(1, None, None),
      name='look_ahead_mask')(dec_inputs)

  # 디코더의 패딩 마스크(두번째 서브층)
  dec_padding_mask = tf.keras.layers.Lambda(
      create_padding_mask, output_shape=(1, 1, None),
      name='dec_padding_mask')(inputs)

  # 인코더의 출력은 enc_outputs. 디코더로 전달된다.
  enc_outputs = encoder(vocab_size=vocab_size, num_layers=num_layers, dff=dff,
      d_model=d_model, num_heads=num_heads, dropout=dropout,
  )(inputs=[inputs, enc_padding_mask]) # 인코더의 입력은 입력 문장과 패딩 마스크

  # 디코더의 출력은 dec_outputs. 출력층으로 전달된다.
  dec_outputs = decoder(vocab_size=vocab_size, num_layers=num_layers, dff=dff,
      d_model=d_model, num_heads=num_heads, dropout=dropout,
  )(inputs=[dec_inputs, enc_outputs, look_ahead_mask, dec_padding_mask])

  # 다음 단어 예측을 위한 출력층
  outputs = tf.keras.layers.Dense(units=vocab_size, name="outputs")(dec_outputs)

  return tf.keras.Model(inputs=[inputs, dec_inputs], outputs=outputs, name=name)

small_transformer = transformer(
    vocab_size = 9000,
    num_layers = 4,
    dff = 512,
    d_model = 128,
    num_heads = 4,
    dropout = 0.3,
    name = "small_transformer"
)

tf.keras.utils.plot_model(
    small_transformer, to_file="small_transformer.png", show_shapes=True
)

def loss_function(y_true, y_pred):
    y_true = tf.reshape(y_true, shape=(-1, max_length-1))

    loss = tf.keras.losses.SparseCategoricalCrossentropy(
        from_logits=True, reduction='none')(y_true, y_pred)

    mask = tf.cast(tf.not_equal(y_true, 0), tf.float32)
    loss = tf.multiply(loss, mask)
    return tf.reduce_mean(loss)

"""$$ lr = d_{model}^{-0.5} \times  min(stepnum^{-0.5}, stepnum \times warmupsteps^{-1.5})$$"""

class CustomSchedule(tf.keras.optimizers.schedules.LearningRateSchedule):
    def __init__(self, d_model, warmup_steps=4000):
        super(CustomSchedule, self).__init__()
        self.d_model = d_model
        self.d_model = tf.cast(self.d_model, tf.float32)
        self.warmup_steps = warmup_steps

    def __call__(self, step):
        arg1 = tf.math.rsqrt(step)
        arg2 = step * (self.warmup_steps** -1.5)
        return tf.math.rsqrt(self.d_model) * tf.math.minimum(arg1, arg2)

sample_learning_rate = CustomSchedule(d_model=128)
plt.plot(sample_learning_rate(tf.range(200000, dtype=tf.float32)))
plt.ylabel("Learning Rate")
plt.xlabel("Train Step")

"""## 트랜스포머를 이용한 챗봇"""

import pandas as pd
import urllib.request
import tensorflow_datasets as tfds
import tensorflow as tf
import time
import numpy as np
import matplotlib.pyplot as plt
import re

urllib.request.urlretrieve("https://raw.githubusercontent.com/songys/Chatbot_data/master/ChatbotData.csv", filename="ChatBotData.csv")

train_data = pd.read_csv('ChatBotData.csv')
train_data.head()

print('챗봇 샘플의 갯수 :',len(train_data))

print(train_data.isnull().sum())

questions = []
for sentence in train_data['Q']:
    sentence = re.sub(r"([?.!,])", r" \1 ", sentence) # 구두점에 대해서 띄어쓰기 
    # 12시 땡! -> 12시 땡 !
    sentence = sentence.strip()
    questions.append(sentence)

answers=[]
for sentence in train_data['A']:
    sentence = re.sub(r"([?.!,])", r" \1 ", sentence) # 구두점에 대해서 띄어쓰기 
    # 12시 땡! -> 12시 땡 !
    sentence = sentence.strip()
    answers.append(sentence)

len(questions)

len(answers)

print(questions[:5])
print(answers[:5])

tokenizer = tfds.deprecated.text.SubwordTextEncoder.build_from_corpus(
    questions + answers, target_vocab_size = 2**13
)

start_token, end_token = [tokenizer.vocab_size], [tokenizer.vocab_size + 1]

vocab_size = tokenizer.vocab_size +2

print('시작 토큰 번호 :', start_token)
print('종료 토큰 번호 :', end_token)
print('단어 집합의 크기 :', vocab_size)

print('Tokenized sample question: {}'.format(tokenizer.encode(questions[20])))

# .encode() decode()

sample_string = questions[20]

tokenized_string = tokenizer.encode(sample_string)
print('정수 인코딩 후의 문장 {}'.format(tokenized_string))

# decode 정수 -> 텍스트
original_string = tokenizer.decode(tokenized_string)
print('기존 문장: {}'.format(original_string))

for ts in tokenized_string:
    print('{}--->{}'.format(ts, tokenizer.decode([ts])))

max_length = 40

def tokenize_and_filter(inputs, outputs):
    tokenized_inputs, tokenized_outputs = [], []

    for (sentence1, sentence2) in zip(inputs, outputs):
        # encode (토큰화 + 정수 인코딩), 시작 토큰과 종료 토큰 추가
        sentence1 = start_token + tokenizer.encode(sentence1) + end_token
        sentence2 = start_token + tokenizer.encode(sentence2) + end_token

        tokenized_inputs.append(sentence1)
        tokenized_outputs.append(sentence2)

    # 패딩
    tokenized_inputs = tf.keras.preprocessing.sequence.pad_sequences(
        tokenized_inputs, maxlen = max_length, padding='post'
    )
    tokenized_outputs = tf.keras.preprocessing.sequence.pad_sequences(
        tokenized_outputs, maxlen=max_length, padding='post'
    )

    return tokenized_inputs, tokenized_outputs

questions, answers = tokenize_and_filter(questions, answers)

print('질문 데이터의 크기 (shape) :', questions.shape)
print('답변 데이터의 크기 (shape) :', answers.shape)

print(questions[0])
print(answers[0])

print('단어 집합의 크기 (VOCAB size): {}'.format(vocab_size))
print('전체 샘플의 수 (Number of samples): {}'.format(len(questions)))

batch_size = 64
buffer_size = 20000

dataset = tf.data.Dataset.from_tensor_slices((
    {
        'inputs' : questions,
        'dec_inputs' : answers[:, :-1] # 디코더의 입력과 마지막 패딩 토큰이 제거
    },
    {
        'outputs': answers[:, 1:] #맨 처음 토큰이 제거된다. 시작토큰 제거
    },
))

dataset = dataset.cache()
dataset = dataset.shuffle(buffer_size)
dataset = dataset.batch(batch_size)
dataset = dataset.prefetch(tf.data.experimental.AUTOTUNE)

print(answers[0])
print(answers[:1][:, :-1]) # 마지막 패딩 토큰이 제거
print(answers[:1][:, 1:]) # 맨 처음 토큰이 제거

tf.keras.backend.clear_session()

num_layers = 2
d_model = 256
num_heads = 8
dff = 512
dropout = 0.1

model = transformer(
    vocab_size = vocab_size,
    num_layers = num_layers,
    dff = dff,
    d_model = d_model,
    num_heads = num_heads,
    dropout = dropout
)

max_length = 40
learning_rate = CustomSchedule(d_model)
optimizer = tf.keras.optimizers.Adam(
    learning_rate, beta_1 =0.9, beta_2 = 0.98, epsilon=1e-9
)

def accuracy(y_true, y_pred):
    y_true = tf.reshape(y_true, shape = (-1, max_length -1))
    return tf.keras.metrics.sparse_categorical_accuracy(y_true, y_pred)

model.compile(optimizer=optimizer, loss = loss_function, metrics = [accuracy])

epochs = 50

model.fit(dataset, epochs = epochs)

def evaluate(sentence):
    sentence = preprocess_sentence(sentence)

    sentence = tf.expand_dims(start_token + tokenizer.encode(sentence) + end_token, axis = 0)

    output = tf.expand_dims(start_token, 0)

    # 디코더의 예측 시작
    for i in range(max_length):
        predictions = model(inputs=[sentence, output], training=False)

        # 현재 (마지막) 시점의 예측 단어를 받아온다.
        predictions = predictions[:, -1:, :]
        predicted_id = tf.cast(tf.argmax(predictions, axis=-1), tf.int32)

        # 만약 마지막 시점의 예측 단어가 종료 토큰이라면 예측을 중단
        if tf.equal(predicted_id, end_token[0]):
            break
        
        # 마지막 시점의 예측 단어를 출력해 연결한다.
        # for문을 통해서 디코더의 입력으로 사용될 예정이다.
        output = tf.concat([output, predicted_id], axis=-1)

    return tf.squeeze(output, axis=0)

def predict(sentence):
    prediction = evaluate(sentence)
    predicted_sentence = tokenizer.decode(
        [i for i in prediction if i < tokenizer.vocab_size]
    )

    print('Input : {}'.format(sentence))
    print('Output : {}'.format(predicted_sentence))

    return predicted_sentence

def preprocess_sentence(sentence):
    sentence = re.sub(r"([?.!,])", r" \1 ", sentence)
    sentence = sentence.strip()
    return sentence

output = predict("영화 볼래?")

output = predict("고민이 있어")

output = predict("너무 화가 나.. ")

output = predict("오늘이 마지막이야")

output = predict("12시 땡!")

output = predict("3박 4일 놀러가고 싶다")

output = predict("오늘 헤어졌다구!! 나 너무 슬퍼")

"""## pretrained model 제작"""

!pip install sentencepiece
!pip install tqdm

import tensorflow as tf
import tensorflow.keras.backend as K
import os
import re
import math
import numpy as np
import pandas as pd
import random
import collections
import json
import shutil
import zipfile
import copy
from datetime import datetime

import matplotlib.pyplot as plt
import sentencepiece as spm
from tqdm import tqdm

random_seed = 1234
random.seed(random_seed)
np.random.seed(random_seed)
tf.random.set_seed(random_seed)

corpus = './kowiki.txt'
prefix = 'ko_8000'
vocab_size = 8000

spm.SentencePieceTrainer.train(
    f"--input={corpus} --model_prefix={prefix} --vocab_size={vocab_size + 7}" +
    " --model_type=bpe" +
    " --max_sentence_length=999999" +
    " --pad_id=0 --pad_piece=[PAD]" +
    " --unk_id=1 --unk_piece=[UNK]" +
    " --bos_id=2 --bos_piece=[BOS]" +
    " --eos_id=3 --eos_piece=[EOS]" +
    " --user_defined_symbols=[SEP],[CLS],[MASK]")

data_dir = './'
model_dir = './'

vocab = spm.SentencePieceProcessor()
vocab.load(f"{model_dir}/ko_8000.model")

vocab_list = []
for id in range(7, len(vocab)):
    if not vocab.is_unknown(id):
        vocab_list.append(vocab.id_to_piece(id))
print(vocab_list)

sample_string = '추적추적 비가 내리는 날이었어 그날은 왠지 손님이 많아 첫 번에 삼십 전 둘째번 오십 전 오랜만에 받아보는 십 전짜리 백통화 서푼에'
sample_string2 = "손바닥 위엔 기쁨이 눈물이 흘러 컬컬한 목에 모주 한잔을 적셔 몇 달 포 전부터 콜록거리는 아내 생각에 그토록 먹고 싶다던"
tokens_org = ["[CLS]"] + vocab.encode_as_pieces(sample_string) + ["[SEP]"] + vocab.encode_as_pieces(sample_string2) + ["[SEP]"]
print(tokens_org)

"""### 데이터 전처리"""

#print(tokens_org)

mask_cnt = int((len(tokens_org) -3) * 0.15)
mask_cnt

"""subword 기반으로 토크나이징을 했을 때, _대, [MASK], 민국이라고 가운데를 마스킹했을 경우 해당 [MASK]가 '한'일 거라는 건 너무 잘 알죠? 그래서 Masked LM 태스크를 구성할 땐 띄어쓰기 단위로 한꺼번에 마스킹해 주는 것이 좋습니다"""

# 띄어쓰기 단위로 mask하기 위해서 index를 분할
cand_idx = [] # word단위의 index array
for (i, token) in enumerate(tokens_org):
    if token == "[CLS]" or token == "[SEP]":
        continue
    if 0 < len(cand_idx) and not token.startswith(u"\u2581"):
        cand_idx[-1].append(i)
    else:
        cand_idx.append([i])

for cand in cand_idx:
    print(cand, [tokens_org[i] for i in cand])

random.shuffle(cand_idx)
cand_idx

# 개선된 마스킹 로직 구현
# tokens가 mask되므로 재 실행을 위해서 넣어줌 (테스트용)
tokens = copy.deepcopy(tokens_org)

mask_lms = [] # mask된 값
for index_set in cand_idx:
    if len(mask_lms) >= mask_cnt: # 현재 mask된 갯수가 15%를 넘으면 중지
        break
    if len(mask_lms) + len(index_set) > mask_cnt: # mask할 갯수를 포함해서 15% 넘으면 skip
        continue
    dice = random.random() # 0..1 사이의 확률 값

    for index in index_set:
        masked_token = None
        if dice < 0.8: # 80% 대체된다 [mask]
            masked_token = "[MASK]"
        elif dice < 0.9:
            masked_token = tokens[index]
        else: # 10% random word
            masked_token = random.choice(vocab_list)
        mask_lms.append({"index":index, "label":tokens[index]})
        tokens[index] = masked_token

print(tokens_org)
print(tokens)

mask_lms = sorted(mask_lms, key=lambda x: x['index'])
mask_idx = [p["index"] for p in mask_lms]
mask_label = [p["label"] for p in mask_lms]

print(mask_idx)
print(mask_label)

"""## Masked LM을 위한 코퍼스 생성 메소드"""

def create_pretrain_mask(tokens, mask_cnt, vocab_list):
    """
    마스크 생성
    : param tokens : tokens
    : param mask_cnt : mask 갯수 (전체 tokens의 15%)
    : param vocab_list : vocab list (random token용)
    : return tokens : mask된 tokens
    : return mask_idx : mask된 token의 index
    : return mask_label : mask된 token의 원래 값
    """

   # 단어 단위로 mask 하기 위해서 index 분할
    cand_idx = []  # word 단위의 index array
    for (i, token) in enumerate(tokens):
        if token == "[CLS]" or token == "[SEP]":
            continue
        if 0 < len(cand_idx) and not token.startswith(u"\u2581"):
            cand_idx[-1].append(i)
        else:
            cand_idx.append([i])
    # random mask를 위해서 순서를 섞음
    random.shuffle(cand_idx)

    mask_lms = []  # mask 된 값
    for index_set in cand_idx:
        if len(mask_lms) >= mask_cnt:  # 현재 mask된 개수가 15%를 넘으면 중지
            break
        if len(mask_lms) + len(index_set) > mask_cnt:  # 이번에 mask할 개수를 포함해 15%를 넘으면 skip
            continue
        dice = random.random()  # 0..1 사이의 확률 값
        for index in index_set:
            masked_token = None
            if dice < 0.8:  # 80% replace with [MASK]
                masked_token = "[MASK]"
            elif dice < 0.9: # 10% keep original
                masked_token = tokens[index]
            else:  # 10% random word
                masked_token = random.choice(vocab_list)
            mask_lms.append({"index": index, "label": tokens[index]})
            tokens[index] = masked_token
    # mask_lms 정렬 후 mask_idx, mask_label 추출
    mask_lms = sorted(mask_lms, key=lambda x: x["index"])
    mask_idx = [p["index"] for p in mask_lms]  # mask된 token의 index
    mask_label = [p["label"] for p in mask_lms]  # mask된 token의 원래 값

    return tokens, mask_idx, mask_label

# 수행 결과 확인
# tokens가 mask되므로 재 실행을 위해서 넣어줌 (테스트용)
tokens = copy.deepcopy(tokens_org)

tokens, mask_idx, mask_label = create_pretrain_mask(tokens, mask_cnt, vocab_list)
print(tokens_org)
print(tokens)
print(mask_idx)
print(mask_label)

"""![image.png](data:image/png;base64,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)

### NSP (Next Sentence Prediction) pair 생성
"""

string = """추적추적 비가 내리는 날이었어
그날은 왠지 손님이 많아
첫 번에 삼십 전 둘째번 오십 전
오랜만에 받아보는 십 전짜리 백통화 서푼에
손바닥 위엔 기쁨의 눈물이 흘러
컬컬한 목에 모주 한잔을 적셔
몇 달 포 전부터 콜록거리는 아내
생각에 그토록 먹고 싶다던
설렁탕 한 그릇을 이제는 살 수 있어
집으로 돌아가는 길 난 문득 떠올라
아내의 목소리가 거칠어만 가는 희박한 숨소리가
오늘은 왠지 나가지 말라던 내 옆에 있어 달라던
그리도 나가고 싶으면 일찍이라도 들어와 달라던
아내의 간절한 목소리가 들려와
나를 원망하듯 비는 점점 거세져
싸늘히 식어가는 아내가 떠올라 걱정은 더해져
난 몰라 오늘은 운수 좋은 날
난 맨날 이렇게 살 수 있으면 얼마나 좋을까"""

doc = [vocab.encode_as_pieces(line) for line in string.split("\n")]
doc[:3]

n_test_seq = 64
min_seq = 8
# [CLS], tokens_a, [SEP], tokens_b, [SEP]
max_seq = n_test_seq -3

current_chunk = []
current_length = 0
for i in range(len(doc)): 
    current_chunk.append(doc[i]) # line단위로 추가
    current_length += len(doc[i]) # current_chunk의 token 수
    if 1 < len(current_chunk) and (i == len(doc) -1 or current_length >= max_seq): #마지막 줄이거나 길이가 max_seq 이상인 경우
        print('current_chunk:', len(current_chunk), current_length, current_chunk)

        #######
        # token a
        a_end = 1
        if 1 < len(current_chunk):
            a_end = random.randrange(1, len(current_chunk))
        tokens_a = []
        for j in range(a_end):
            tokens_a.extend(current_chunk[j])

        # token b
        tokens_b = []
        for j in range(a_end, len(current_chunk)):
            tokens_b.extend(current_chunk[j])
        #######  
        
        print("tokens_a:", len(tokens_a), tokens_a)
        print("tokens_b:", len(tokens_b), tokens_b)
        print()

        current_chunk = []
        current_length = 0

def trim_tokens(tokens_a, tokens_b, max_seq):
    """
    tokens_a, tokens_b의 길이를 줄임 최대 길이: max_seq
    :param tokens_a: tokens A
    :param tokens_b: tokens B
    :param max_seq: 두 tokens 길이의 최대 값
    """

    while True:
        total_length = len(tokens_a) + len(tokens_b)
        if total_length <= max_seq:
            break
        
        if len(tokens_a) > len(tokens_b):
            del tokens_a[0]
        else:
            tokens_b.pop()

current_chunk = []
current_length = 0
for i in range(len(doc)): 
    current_chunk.append(doc[i]) # line단위로 추가
    current_length += len(doc[i]) # current_chunk의 token 수
    if 1 < len(current_chunk) and (i == len(doc) -1 or current_length >= max_seq): #마지막 줄이거나 길이가 max_seq 이상인 경우
        print('current_chunk:', len(current_chunk), current_length, current_chunk)

        #######
        # token a
        a_end = 1
        if 1 < len(current_chunk):
            a_end = random.randrange(1, len(current_chunk))
        tokens_a = []
        for j in range(a_end):
            tokens_a.extend(current_chunk[j])

        # token b
        tokens_b = []
        for j in range(a_end, len(current_chunk)):
            tokens_b.extend(current_chunk[j])
        #######  

        if random.random() < 0.5: # 50% 확률로 swap
            is_next = 0
            tokens_t = tokens_a
            tokens_a = tokens_b
            tokens_b = tokens_t
        else:
            is_nest = 1
        # max_seq보다 큰 경우 길이 조절
        trim_tokens(tokens_a, tokens_b, max_seq)
        assert 0 < len(tokens_a)
        assert 0 < len(tokens_b)

        print("is_next :", is_next)
        
        print("tokens_a:", len(tokens_a), tokens_a)
        print("tokens_b:", len(tokens_b), tokens_b)
        print()

        current_chunk = []
        current_length = 0

# 두 문장들 사이에 segment 처리
# 첫 문장의 segment는 모두 0으로, 두 번째 문장은 1로 채워준 후 둘 사이의 구분자 [SEP] 삽입

instances = []
current_chunk = []
current_length = 0
for i in range(len(doc)): 
    current_chunk.append(doc[i]) # line단위로 추가
    current_length += len(doc[i]) # current_chunk의 token 수
    if 1 < len(current_chunk) and (i == len(doc) -1 or current_length >= max_seq): #마지막 줄이거나 길이가 max_seq 이상인 경우
        print('current_chunk:', len(current_chunk), current_length, current_chunk)

        #######
        # token a
        a_end = 1
        if 1 < len(current_chunk):
            a_end = random.randrange(1, len(current_chunk))
        tokens_a = []
        for j in range(a_end):
            tokens_a.extend(current_chunk[j])

        # token b
        tokens_b = []
        for j in range(a_end, len(current_chunk)):
            tokens_b.extend(current_chunk[j])
        #######  

        if random.random() < 0.5: # 50% 확률로 swap
            is_next = 0
            tokens_t = tokens_a
            tokens_a = tokens_b
            tokens_b = tokens_t
        else:
            is_nest = 1
        # max_seq보다 큰 경우 길이 조절
        trim_tokens(tokens_a, tokens_b, max_seq)
        assert 0 < len(tokens_a)
        assert 0 < len(tokens_b)

        print("is_next :", is_next)
        print("tokens_a:", len(tokens_a), tokens_a)
        print("tokens_b:", len(tokens_b), tokens_b)

        #####
        # tokens & segment 생성
        tokens = ["[CLS]"] + tokens_a + ["[SEP]"] + tokens_b + ["SEP"]
        segment = [0] * (len(tokens_a) +2) + [1] * (len(tokens_b) +1)
        print("tokens :", len(tokens), tokens)
        print("segment :", len(segment), segment)

        # mask
        tokens, mask_idx, mask_label = create_pretrain_mask(tokens, int((len(tokens)-3)* 0.15), vocab_list)
        print("masked tokens :", len(tokens), tokens)
        print("masked index :", len(mask_idx), mask_idx)
        print("masked label :", len(mask_label), mask_label)

        instance = {
            "tokens" : tokens,
            "segment" : segment,
            "is_next" : is_next,
            "mask_idx": mask_idx,
            "mask_label" : mask_label
        }
        instances.append(instance)


        print()

        current_chunk = []
        current_length = 0

for instance in instances:
    print(instance)

"""### Next Sentence Prediction을 위한 코퍼스 생성 메소드"""

def create_pretrain_instances(vocab, doc, n_seq, mask_prob, vocab_list):
    """
    doc별 pretrain 데이터 생성
    """
    # for CLS], [SEP], [SEP]
    max_seq = n_seq - 3

    instances = []
    current_chunk = []
    current_length = 0
    for i in range(len(doc)):
        current_chunk.append(doc[i])  # line
        current_length += len(doc[i])
        if 1 < len(current_chunk) and (i == len(doc) - 1 or current_length >= max_seq):
            # token a
            a_end = 1
            if 1 < len(current_chunk):
                a_end = random.randrange(1, len(current_chunk))
            tokens_a = []
            for j in range(a_end):
                tokens_a.extend(current_chunk[j])
            # token b
            tokens_b = []
            for j in range(a_end, len(current_chunk)):
                tokens_b.extend(current_chunk[j])

            if random.random() < 0.5:  # 50% 확률로 swap
                is_next = 0
                tokens_t = tokens_a
                tokens_a = tokens_b
                tokens_b = tokens_t
            else:
                is_next = 1
            # max_seq 보다 큰 경우 길이 조절
            trim_tokens(tokens_a, tokens_b, max_seq)
            assert 0 < len(tokens_a)
            assert 0 < len(tokens_b)
            # tokens & aegment 생성
            tokens = ["[CLS]"] + tokens_a + ["[SEP]"] + tokens_b + ["[SEP]"]
            segment = [0] * (len(tokens_a) + 2) + [1] * (len(tokens_b) + 1)
            # mask
            tokens, mask_idx, mask_label = create_pretrain_mask(tokens, int((len(tokens) - 3) * mask_prob), vocab_list)

            instance = {
                "tokens": tokens,
                "segment": segment,
                "is_next": is_next,
                "mask_idx": mask_idx,
                "mask_label": mask_label
            }
            instances.append(instance)

            current_chunk = []
            current_length = 0
    return instances

# 수행 결과 확인
instances = create_pretrain_instances(vocab, doc, n_test_seq, 0.15, vocab_list)

# 최종 데이터셋 결과 확인
for instance in instances:
    print(instance)

"""### 데이터셋 완성"""

corpus_file = './kowiki.txt'

total = 0
with open(corpus_file, 'r') as in_f:
    for line in in_f:
        total += 1
total

# 위키가 주제별로 잘 나눠지는지 여부 확인
count = 5

with open(corpus_file, 'r') as in_f:
    doc = [] # 단락 단위로 문서 저장
    for line in tqdm(in_f, total= total):
        line = line.strip()
        if line == "": # line이 빈줄 일 경우 (새로운 단락을 의미 함.)
            if 0 < len(doc):
                if 0 < count:
                    count -= 1
                    print(len(doc), "lines", doc[0])
                    print(doc[1])
                    print(doc[-1])
                    print()
                else:
                    break
                doc = []
        else:
            pieces = vocab.encode_as_pieces(line)
            if 0 < len(pieces):
                doc.append(pieces)
    if 0 < len(doc):
        print(doc[0])
        print(doc[1])
        print(doc[-1])
        doc = []

# instance 생성 기능 확인
count = 5

with open(corpus_file, 'r') as in_f:
    doc = []  # 단락 단위로 문서 저장
    for line in tqdm(in_f, total=total):
        line = line.strip()
        if line == "":  # line이 빈줄 일 경우 (새로운 단락을 의미 함)
            if 0 < len(doc):
                instances = create_pretrain_instances(vocab, doc, n_test_seq, 0.15, vocab_list)
                # save
                print("doc:", len(doc), "instances:", len(instances))
                print(instances[0])
                print(instances[-1])
                print()
                doc = []
                if 0 < count:  # 테스트를 위해서 부분 처리 함
                    count -= 1
                else:
                    break
        else:  # doc에 저장
            if 0 < len(pieces):
                doc.append(pieces)
    if 0 < len(doc):  # 마지막에 처리되지 않은 doc가 있는 경우
        instances = create_pretrain_instances(doc, 128)
        # save
        print("doc:", len(doc), "instances:", len(instances))
        print(instances[0])
        print(instances[-1])
        print()
        doc = []

"""### BERT pretrain 데이터셋 생성 메소드"""

def make_pretrain_data(vocab, in_file, out_file, n_seq, mask_prob=0.15):
    def save_pretrain_instances(out_f, doc):
        instances = create_pretrain_instances(vocab, doc, n_seq, mask_prob, vocab_list)
        for instance in instances:
            out_f.write(json.dumps(instance, ensure_ascii=False))
            out_f.write("\n")
    
    # 특수문자 7개를 제외한 vocab_list 생성
    vocab_list = []
    for id in range(7, len(vocab)):
        if not vocab.is_unknown(id):
            vocab_list.append(vocab.id_to_piece(id))
    
    # line count 확인
    line_cnt = 0
    with open(in_file, "r") as in_f:
        for line in in_f:
            line_cnt += 1
    
    with open(in_file, "r") as in_f:
        with open(out_file, "w") as out_f:
            doc = []
            for line in tqdm(in_f, total=line_cnt):
                line = line.strip()
                if line == "":  # line이 빈줄 일 경우 (새로운 단락을 의미 함)
                    if 0 < len(doc):
                        save_pretrain_instances(out_f, doc)
                        doc = []
                else:  # line이 빈줄이 아닐 경우 tokenize 해서 doc에 저장
                    pieces = vocab.encode_as_pieces(line)
                    if 0 < len(pieces):
                        doc.append(pieces)
            if 0 < len(doc):  # 마지막에 처리되지 않은 doc가 있는 경우
                save_pretrain_instances(out_f, doc)
                doc = []

pretrain_json_path = './bert_pre_train.json'
make_pretrain_data(vocab, corpus_file, pretrain_json_path, 128)

# 라인수
total = 0
with open(pretrain_json_path, "r") as f:
    for line in f:
        total += 1
total # 862285

n_seq = 128
# [CLS], tokens_a, [SEP], tokens_b, [SEP]
max_seq = n_seq - 3

# 만약 일반적인 Numpy Array에다 데이터를 로딩한다면 이렇게 되겠지만
# enc_tokens = np.zeros((total, n_seq), np.int32)
# dec_tokens = np.zeros((total, n_seq), np.int32)
# labels_nsp = np.zeros((total,), np.int32)
# labels_mlm = np.zeros((total, n_seq), np.int32)

# np.memmap을 사용하면 메모리를 적은 메모리에서도 대용량 데이터 처리가 가능 함
enc_tokens = np.memmap(filename='enc_tokens.memmap', mode='w+', dtype=np.int32, shape=(total, n_seq))
segments = np.memmap(filename='segments.memmap', mode='w+', dtype=np.int32, shape=(total, n_seq))
labels_nsp = np.memmap(filename='labels_nsp.memmap', mode='w+', dtype=np.int32, shape=(total,))
labels_mlm = np.memmap(filename='labels_mlm.memmap', mode='w+', dtype=np.int32, shape=(total, n_seq))


enc_tokens[0], enc_tokens[-1], segments[0], segments[-1], labels_nsp[0], labels_nsp[-1], labels_mlm[0], labels_mlm[-1]

# 만들어진 json파일을 라인 단위로 읽어들여 np.memmap에 로딩
# 라인단위로 처리
with open(pretrain_json_path, "r") as f:
    for i, line in enumerate(tqdm(f, total=total)):
        if 5 < i:  # 테스트를 위해서 5개만 확인
            break
        data = json.loads(line)
        # encoder token
        enc_token = [vocab.piece_to_id(p) for p in data["tokens"]]
        enc_token += [0] * (n_seq - len(enc_token))
        # segment
        segment = data["segment"]
        segment += [0] * (n_seq - len(segment))
        # nsp label
        label_nsp = data["is_next"]
        # mlm label
        mask_idx = np.array(data["mask_idx"], dtype=np.int)
        mask_label = np.array([vocab.piece_to_id(p) for p in data["mask_label"]], dtype=np.int)
        label_mlm = np.full(n_seq, dtype=np.int, fill_value=0)
        label_mlm[mask_idx] = mask_label

        print(data)
        print("enc_token:", enc_token)
        print("segment:", segment)
        print("label_nsp:", label_nsp)
        print("label_mlm:", label_mlm)
        print()

        assert len(enc_token) == len(segment) == len(label_mlm) == n_seq

        enc_tokens[i] = enc_token
        segments[i] = segment
        labels_nsp[i] = label_nsp
        labels_mlm[i] = label_mlm

"""### 학습에 필요한 데이터를 로딩하는 함수"""

def load_pre_train_data(vocab, filename, n_seq, count=None):
    """
    학습에 필요한 데이터를 로드
    :param vocab: vocab
    :param filename: 전처리된 json 파일
    :param n_seq: 시퀀스 길이 (number of sequence)
    :param count: 데이터 수 제한 (None이면 전체)
    :return enc_tokens: encoder inputs
    :return segments: segment inputs
    :return labels_nsp: nsp labels
    :return labels_mlm: mlm labels
    """
    total = 0
    with open(filename, "r") as f:
        for line in f:
            total += 1
            # 데이터 수 제한
            if count is not None and count <= total:
                break
    
    # np.memmap을 사용하면 메모리를 적은 메모리에서도 대용량 데이터 처리가 가능 함
    enc_tokens = np.memmap(filename='enc_tokens.memmap', mode='w+', dtype=np.int32, shape=(total, n_seq))
    segments = np.memmap(filename='segments.memmap', mode='w+', dtype=np.int32, shape=(total, n_seq))
    labels_nsp = np.memmap(filename='labels_nsp.memmap', mode='w+', dtype=np.int32, shape=(total,))
    labels_mlm = np.memmap(filename='labels_mlm.memmap', mode='w+', dtype=np.int32, shape=(total, n_seq))

    with open(filename, "r") as f:
        for i, line in enumerate(tqdm(f, total=total)):
            if total <= i:
                print("data load early stop", total, i)
                break
            data = json.loads(line)
            # encoder token
            enc_token = [vocab.piece_to_id(p) for p in data["tokens"]]
            enc_token += [0] * (n_seq - len(enc_token))
            # segment
            segment = data["segment"]
            segment += [0] * (n_seq - len(segment))
            # nsp label
            label_nsp = data["is_next"]
            # mlm label
            mask_idx = np.array(data["mask_idx"], dtype=np.int)
            mask_label = np.array([vocab.piece_to_id(p) for p in data["mask_label"]], dtype=np.int)
            label_mlm = np.full(n_seq, dtype=np.int, fill_value=0)
            label_mlm[mask_idx] = mask_label

            assert len(enc_token) == len(segment) == len(label_mlm) == n_seq

            enc_tokens[i] = enc_token
            segments[i] = segment
            labels_nsp[i] = label_nsp
            labels_mlm[i] = label_mlm

    return (enc_tokens, segments), (labels_nsp, labels_mlm)

# 128000건만 메모리에 로딩
pre_train_inputs, pre_train_labels = load_pre_train_data(vocab, pretrain_json_path, 128, count=128000)

# 처음과 마지막을 확인
pre_train_inputs[0][0], pre_train_inputs[0][-1], pre_train_inputs[1][0], pre_train_inputs[1][-1], pre_train_labels[0][0], pre_train_labels[0][-1], pre_train_labels[1][0], pre_train_labels[1][-1],

"""### BERT 모델 구현"""

# 유틸리티 함수 구현
def get_pad_mask(tokens, i_pad=0):
    """
    pad mask 계산하는 함수
    :param tokens: tokens (bs, n_seq)
    :param i_pad: id of pad
    :return mask: pad mask (pad: 1, other: 0)
    """
    mask = tf.cast(tf.math.equal(tokens, i_pad), tf.float32)
    mask = tf.expand_dims(mask, axis=1)
    return mask


def get_ahead_mask(tokens, i_pad=0):
    """
    ahead mask 계산하는 함수
    :param tokens: tokens (bs, n_seq)
    :param i_pad: id of pad
    :return mask: ahead and pad mask (ahead or pad: 1, other: 0)
    """
    n_seq = tf.shape(tokens)[1]
    ahead_mask = 1 - tf.linalg.band_part(tf.ones((n_seq, n_seq)), -1, 0)
    ahead_mask = tf.expand_dims(ahead_mask, axis=0)
    pad_mask = get_pad_mask(tokens, i_pad)
    mask = tf.maximum(ahead_mask, pad_mask)
    return mask

@tf.function(experimental_relax_shapes=True)
def gelu(x):
    """
    gelu activation 함수
    :param x: 입력 값
    :return: gelu activation result
    """
    return 0.5 * x * (1 + K.tanh(x * 0.7978845608 * (1 + 0.044715 * x * x)))

def kernel_initializer(stddev=0.02):
    """
    parameter initializer 생성
    :param stddev: 생성할 랜덤 변수의 표준편차
    """
    return tf.keras.initializers.TruncatedNormal(stddev=stddev)


def bias_initializer():
    """
    bias initializer 생성
    """
    return tf.zeros_initializer

class Config(dict):
    """
    json을 config 형태로 사용하기 위한 Class
    :param dict: config dictionary
    """
    __getattr__ = dict.__getitem__
    __setattr__ = dict.__setitem__

    @classmethod
    def load(cls, file):
        """
        file에서 Config를 생성 함
        :param file: filename
        """
        with open(file, 'r') as f:
            config = json.loads(f.read())
            return Config(config)

# token embedding
class SharedEmbedding(tf.keras.layers.Layer):
    """
    Weighed Shaed Embedding Class
    """
    def __init__(self, config, name="weight_shared_embedding"):
        """
        생성자
        :param config: Config 객체
        :param name: layer name
        """
        super().__init__(name=name)

        self.n_vocab = config.n_vocab
        self.d_model = config.d_model
    
    def build(self, input_shape):
        """
        shared weight 생성
        :param input_shape: Tensor Shape (not used)
        """
        with tf.name_scope("shared_embedding_weight"):
            self.shared_weights = self.add_weight(
                "weights",
                shape=[self.n_vocab, self.d_model],
                initializer=kernel_initializer()
            )

    def call(self, inputs, mode="embedding"):
        """
        layer 실행
        :param inputs: 입력
        :param mode: 실행 모드
        :return: embedding or linear 실행 결과
        """
        # mode가 embedding일 경우 embedding lookup 실행
        if mode == "embedding":
            return self._embedding(inputs)
        # mode가 linear일 경우 linear 실행
        elif mode == "linear":
            return self._linear(inputs)
        # mode가 기타일 경우 오류 발생
        else:
            raise ValueError(f"mode {mode} is not valid.")
    
    def _embedding(self, inputs):
        """
        embedding lookup
        :param inputs: 입력
        """
        embed = tf.gather(self.shared_weights, tf.cast(inputs, tf.int32))
        return embed

    def _linear(self, inputs):  # (bs, n_seq, d_model)
        """
        linear 실행
        :param inputs: 입력
        """
        n_batch = tf.shape(inputs)[0]
        n_seq = tf.shape(inputs)[1]
        inputs = tf.reshape(inputs, [-1, self.d_model])  # (bs * n_seq, d_model)
        outputs = tf.matmul(inputs, self.shared_weights, transpose_b=True)
        outputs = tf.reshape(outputs, [n_batch, n_seq, self.n_vocab])  # (bs, n_seq, n_vocab)
        return outputs

# positional embedding 레이어 구현
class PositionalEmbedding(tf.keras.layers.Layer):
    """
    Positional Embedding Class
    """
    def __init__(self, config, name="position_embedding"):
        """
        생성자
        :param config: Config 객체
        :param name: layer name
        """
        super().__init__(name=name)
        
        self.embedding = tf.keras.layers.Embedding(config.n_seq, config.d_model, embeddings_initializer=kernel_initializer())

    def call(self, inputs):
        """
        layer 실행
        :param inputs: 입력
        :return embed: positional embedding lookup 결과
        """
        position = tf.cast(tf.math.cumsum(tf.ones_like(inputs), axis=1, exclusive=True), tf.int32)
        embed = self.embedding(position)
        return embed

# scale dot product attention
class ScaleDotProductAttention(tf.keras.layers.Layer):
    """
    Scale Dot Product Attention Class
    """
    def __init__(self, name="scale_dot_product_attention"):
        """
        생성자
        :param name: layer name
        """
        super().__init__(name=name)

    def call(self, Q, K, V, attn_mask):
        """
        layer 실행
        :param Q: Q value
        :param K: K value
        :param V: V value
        :param attn_mask: 실행 모드
        :return attn_out: attention 실행 결과
        """
        attn_score = tf.matmul(Q, K, transpose_b=True)
        scale = tf.math.sqrt(tf.cast(tf.shape(K)[-1], tf.float32))
        attn_scale = tf.math.divide(attn_score, scale)
        attn_scale -= 1.e9 * attn_mask
        attn_prob = tf.nn.softmax(attn_scale, axis=-1)
        attn_out = tf.matmul(attn_prob, V)
        return attn_out

# 이를 활용한 multi head attention
class MultiHeadAttention(tf.keras.layers.Layer):
    """
    Multi Head Attention Class
    """
    def __init__(self, config, name="multi_head_attention"):
        """
        생성자
        :param config: Config 객체
        :param name: layer name
        """
        super().__init__(name=name)

        self.d_model = config.d_model
        self.n_head = config.n_head
        self.d_head = config.d_head

        # Q, K, V input dense layer
        self.W_Q = tf.keras.layers.Dense(config.n_head * config.d_head, kernel_initializer=kernel_initializer(), bias_initializer=bias_initializer())
        self.W_K = tf.keras.layers.Dense(config.n_head * config.d_head, kernel_initializer=kernel_initializer(), bias_initializer=bias_initializer())
        self.W_V = tf.keras.layers.Dense(config.n_head * config.d_head, kernel_initializer=kernel_initializer(), bias_initializer=bias_initializer())
        # Scale Dot Product Attention class
        self.attention = ScaleDotProductAttention(name="self_attention")
        # output dense layer
        self.W_O = tf.keras.layers.Dense(config.d_model, kernel_initializer=kernel_initializer(), bias_initializer=bias_initializer())

    def call(self, Q, K, V, attn_mask):
        """
        layer 실행
        :param Q: Q value
        :param K: K value
        :param V: V value
        :param attn_mask: 실행 모드
        :return attn_out: attention 실행 결과
        """
        # reshape Q, K, V, attn_mask
        batch_size = tf.shape(Q)[0]
        Q_m = tf.transpose(tf.reshape(self.W_Q(Q), [batch_size, -1, self.n_head, self.d_head]), [0, 2, 1, 3])  # (bs, n_head, Q_len, d_head)
        K_m = tf.transpose(tf.reshape(self.W_K(K), [batch_size, -1, self.n_head, self.d_head]), [0, 2, 1, 3])  # (bs, n_head, K_len, d_head)
        V_m = tf.transpose(tf.reshape(self.W_V(V), [batch_size, -1, self.n_head, self.d_head]), [0, 2, 1, 3])  # (bs, n_head, K_len, d_head)
        attn_mask_m = tf.expand_dims(attn_mask, axis=1)
        # Scale Dot Product Attention with multi head Q, K, V, attn_mask
        attn_out = self.attention(Q_m, K_m, V_m, attn_mask_m)  # (bs, n_head, Q_len, d_head)
        # transpose and liner
        attn_out_m = tf.transpose(attn_out, perm=[0, 2, 1, 3])  # (bs, Q_len, n_head, d_head)
        attn_out = tf.reshape(attn_out_m, [batch_size, -1, config.n_head * config.d_head])  # (bs, Q_len, d_model)
        attn_out = self.W_O(attn_out) # (bs, Q_len, d_model)

        return attn_out

# transformer encoder 레이어 구현 시작
class PositionWiseFeedForward(tf.keras.layers.Layer):
    """
    Position Wise Feed Forward Class
    """
    def __init__(self, config, name="feed_forward"):
        """
        생성자
        :param config: Config 객체
        :param name: layer name
        """
        super().__init__(name=name)

        self.W_1 = tf.keras.layers.Dense(config.d_ff, activation=gelu, kernel_initializer=kernel_initializer(), bias_initializer=bias_initializer())
        self.W_2 = tf.keras.layers.Dense(config.d_model, kernel_initializer=kernel_initializer(), bias_initializer=bias_initializer())

    def call(self, inputs):
        """
        layer 실행
        :param inputs: inputs
        :return ff_val: feed forward 실행 결과
        """
        ff_val = self.W_2(self.W_1(inputs))
        return ff_val

class EncoderLayer(tf.keras.layers.Layer):
    """
    Encoder Layer Class
    """
    def __init__(self, config, name="encoder_layer"):
        """
        생성자
        :param config: Config 객체
        :param name: layer name
        """
        super().__init__(name=name)

        self.self_attention = MultiHeadAttention(config)
        self.norm1 = tf.keras.layers.LayerNormalization(epsilon=config.layernorm_epsilon)

        self.ffn = PositionWiseFeedForward(config)
        self.norm2 = tf.keras.layers.LayerNormalization(epsilon=config.layernorm_epsilon)

        self.dropout = tf.keras.layers.Dropout(config.dropout)
 
    def call(self, enc_embed, self_mask):
        """
        layer 실행
        :param enc_embed: enc_embed 또는 이전 EncoderLayer의 출력
        :param self_mask: enc_tokens의 pad mask
        :return enc_out: EncoderLayer 실행 결과
        """
        self_attn_val = self.self_attention(enc_embed, enc_embed, enc_embed, self_mask)
        norm1_val = self.norm1(enc_embed + self.dropout(self_attn_val))

        ffn_val = self.ffn(norm1_val)
        enc_out = self.norm2(norm1_val + self.dropout(ffn_val))

        return enc_out

# 최종 BERT 레이어
class BERT(tf.keras.layers.Layer):
    """
    BERT Class
    """
    def __init__(self, config, name="bert"):
        """
        생성자
        :param config: Config 객체
        :param name: layer name
        """
        super().__init__(name=name)

        self.i_pad = config.i_pad
        self.embedding = SharedEmbedding(config)
        self.position = PositionalEmbedding(config)
        self.segment = tf.keras.layers.Embedding(2, config.d_model, embeddings_initializer=kernel_initializer())
        self.norm = tf.keras.layers.LayerNormalization(epsilon=config.layernorm_epsilon)
        
        self.encoder_layers = [EncoderLayer(config, name=f"encoder_layer_{i}") for i in range(config.n_layer)]

        self.dropout = tf.keras.layers.Dropout(config.dropout)

    def call(self, inputs):
        """
        layer 실행
        :param inputs: (enc_tokens, segments)
        :return logits: dec_tokens에 대한 다음 토큰 예측 결과 logits
        """
        enc_tokens, segments = inputs

        enc_self_mask = tf.keras.layers.Lambda(get_pad_mask, output_shape=(1, None), name='enc_self_mask')(enc_tokens, self.i_pad)

        enc_embed = self.get_embedding(enc_tokens, segments)

        enc_out = self.dropout(enc_embed)
        for encoder_layer in self.encoder_layers:
            enc_out = encoder_layer(enc_out, enc_self_mask)

        logits_cls = enc_out[:,0]
        logits_lm = self.embedding(enc_out, mode="linear")
        return logits_cls, logits_lm
    
    def get_embedding(self, tokens, segments):
        """
        token embedding, position embedding lookup
        :param tokens: 입력 tokens
        :param segments: 입력 segments
        :return embed: embedding 결과
        """
        embed = self.embedding(tokens) + self.position(tokens) + self.segment(segments)
        embed = self.norm(embed)
        return embed

class PooledOutput(tf.keras.layers.Layer):
    def __init__(self, config, n_output, name="pooled_output"):
        super().__init__(name=name)

        self.dense1 = tf.keras.layers.Dense(config.d_model, activation=tf.nn.tanh, kernel_initializer=kernel_initializer(), bias_initializer=bias_initializer())
        self.dense2 = tf.keras.layers.Dense(n_output, use_bias=False, activation=tf.nn.softmax, name="nsp", kernel_initializer=kernel_initializer(), bias_initializer=bias_initializer())
 
    def call(self, inputs):
        outputs = self.dense1(inputs)
        outputs = self.dense2(outputs)
        return outputs

def build_model_pre_train(config):
    enc_tokens = tf.keras.layers.Input((None,), name="enc_tokens")
    segments = tf.keras.layers.Input((None,), name="segments")

    bert = BERT(config)
    logits_cls, logits_lm = bert((enc_tokens, segments))

    logits_cls = PooledOutput(config, 2, name="pooled_nsp")(logits_cls)
    outputs_nsp = tf.keras.layers.Softmax(name="nsp")(logits_cls)

    outputs_mlm = tf.keras.layers.Softmax(name="mlm")(logits_lm)

    model = tf.keras.Model(inputs=(enc_tokens, segments), outputs=(outputs_nsp, outputs_mlm))
    return model

# 아주 작은 pretrain용 BERT 모델을 생성해 동작 확인
config = Config({"d_model": 256, "n_head": 4, "d_head": 64, "dropout": 0.1, "d_ff": 1024, "layernorm_epsilon": 0.001, "n_layer": 3, "n_seq": 256, "n_vocab": 0, "i_pad": 0})
config.n_vocab = len(vocab)
config.i_pad = vocab.pad_id()
config

n_seq = 10

# make test inputs
enc_tokens = np.random.randint(0, len(vocab), (10, n_seq))
segments = np.random.randint(0, 2, (10, n_seq))
labels_nsp = np.random.randint(0, 2, (10,))
labels_mlm = np.random.randint(0, len(vocab), (10, n_seq))

test_model = build_model_pre_train(config)
test_model.compile(loss=tf.keras.losses.sparse_categorical_crossentropy, optimizer=tf.keras.optimizers.Adam(), metrics=["acc"])

# test model fit
test_model.fit((enc_tokens, segments), (labels_nsp, labels_mlm), epochs=2, batch_size=5)

"""### Pretrain 진행"""

# loss, accuracy 등 기본적으로 필요한 계산 함수 정의
def lm_loss(y_true, y_pred):
    """
    loss 계산 함수
    :param y_true: 정답 (bs, n_seq)
    :param y_pred: 예측 값 (bs, n_seq, n_vocab)
    """
    # loss 계산
    loss = tf.keras.losses.SparseCategoricalCrossentropy(reduction=tf.keras.losses.Reduction.NONE)(y_true, y_pred)
    # pad(0) 인 부분 mask
    mask = tf.cast(tf.math.not_equal(y_true, 0), dtype=loss.dtype)
    loss *= mask
    return loss * 20  # mlm을 더 잘 학습하도록 20배 증가 시킴

def lm_acc(y_true, y_pred):
    """
    acc 계산 함수
    :param y_true: 정답 (bs, n_seq)
    :param y_pred: 예측 값 (bs, n_seq, n_vocab)
    """
    # 정답 여부 확인
    y_pred_class = tf.cast(K.argmax(y_pred, axis=-1), tf.float32)
    matches = tf.cast(K.equal(y_true, y_pred_class), tf.float32)
    # pad(0) 인 부분 mask
    mask = tf.cast(tf.math.not_equal(y_true, 0), dtype=matches.dtype)
    matches *= mask
    # 정확도 계산
    accuracy = K.sum(matches) / K.maximum(K.sum(mask), 1)
    return accuracy

# learning rate scheduler 구현
class CosineSchedule(tf.keras.optimizers.schedules.LearningRateSchedule):
    """
    CosineSchedule Class
    """
    def __init__(self, train_steps=4000, warmup_steps=2000, max_lr=2.5e-4):
        """
        생성자
        :param train_steps: 학습 step 총 합
        :param warmup_steps: warmup steps
        :param max_lr: 최대 learning rate
        """
        super().__init__()

        assert 0 < warmup_steps < train_steps
        self.warmup_steps = warmup_steps
        self.train_steps = train_steps
        self.max_lr = max_lr

    def __call__(self, step_num):
        """
        learning rate 계산
        :param step_num: 현재 step number
        :retrun: 계산된 learning rate
        """
        state = tf.cast(step_num <= self.warmup_steps, tf.float32)
        lr1 = tf.cast(step_num, tf.float32) / self.warmup_steps
        progress = tf.cast(step_num - self.warmup_steps, tf.float32) / max(1, self.train_steps - self.warmup_steps)
        lr2 = 0.5 * (1.0 + tf.math.cos(math.pi * progress))
        return (state * lr1 + (1 - state) * lr2) * self.max_lr

# 스케줄러 테스트
# compute lr 
test_schedule = CosineSchedule(train_steps=4000, warmup_steps=500)
lrs = []
for step_num in range(4000):
    lrs.append(test_schedule(float(step_num)).numpy())

# draw
plt.plot(lrs, 'r-', label='learning_rate')
plt.xlabel('Step')
plt.show()

# 모델 생성
pre_train_model = build_model_pre_train(config)
pre_train_model.summary()

# 학습 (전체 데이터셋의 1/7 수준인 128000건만 사용)
epochs = 3
batch_size = 64

# optimizer
train_steps = math.ceil(len(pre_train_inputs[0]) / batch_size) * epochs
print("train_steps:", train_steps)
learning_rate = CosineSchedule(train_steps=train_steps, warmup_steps=max(100, train_steps // 10))
optimizer = tf.keras.optimizers.Adam(learning_rate, beta_1=0.9, beta_2=0.98, epsilon=1e-9)

# compile
pre_train_model.compile(loss=(tf.keras.losses.sparse_categorical_crossentropy, lm_loss), optimizer=optimizer, metrics={"nsp": "acc", "mlm": lm_acc})

# save weights callback
save_weights = tf.keras.callbacks.ModelCheckpoint(f"{model_dir}/bert_pre_train.hdf5", monitor="mlm_lm_acc", verbose=1, save_best_only=True, mode="max", save_freq="epoch", save_weights_only=True)
# train
history = pre_train_model.fit(pre_train_inputs, pre_train_labels, epochs=epochs, batch_size=batch_size, callbacks=[save_weights])

# training result
plt.figure(figsize=(12, 4))

plt.subplot(1, 2, 1)
plt.plot(history.history['nsp_loss'], 'b-', label='nsp_loss')
plt.plot(history.history['mlm_loss'], 'r--', label='mlm_loss')
plt.xlabel('Epoch')
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(history.history['nsp_acc'], 'g-', label='nsp_acc')
plt.plot(history.history['mlm_lm_acc'], 'k--', label='mlm_acc')
plt.xlabel('Epoch')
plt.legend()

plt.show()

